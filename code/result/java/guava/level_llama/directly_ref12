1 Cleanup collected entries when the lock is available.
2 Resolves all type variables in {@code type} and all downstream types and returns a corresponding type with type variables resolved.
3 {@code A.is(B)} is defined as {@code Foo<A>.isSubtypeOf(Foo<B>)}. <p>Specifically, returns true if any of the following conditions is met: <ol> <li>'this' and {@code formalType} are equal. <li>'this' and {@code formalType} have equal canonical form. <li>{@code formalType} is {@code <? extends Foo>} and 'this' is a subtype of {@code Foo}. <li>{@code formalType} is {@code <? super Foo>} and 'this' is a supertype of {@code Foo}. </ol> Note that condition 2 isn't technically accurate under the context of a recursively bounded type variables. For example, {@code Enum<? extends Enum<E>>} canonicalizes to {@code Enum<?>} where {@code E} is the type variable declared on the {@code Enum} class declaration. It's technically <em>not</em> true that {@code Foo<Enum<? extends Enum<E>>>} is a subtype of {@code Foo<Enum<?>>} according to JLS. See testRecursiveWildcardSubtypeBug() for a real example. <p>It appears that properly handling recursive type bounds in the presence of implicit type bounds is not easy. For now we punt, hoping that this defect should rarely cause issues in real code. @param formalType is {@code Foo<formalType>} a supertype of {@code Foo<T>}? @param declaration The type variable in the context of a parameterized type. Used to infer type bound when {@code formalType} is a wildcard with implicit upper bound.
4 In reflection, {@code Foo<?>.getUpperBounds()[0]} is always {@code Object.class}, even when Foo is defined as {@code Foo<T extends String>}. Thus directly calling {@code <?>.is(String.class)} will return false. To mitigate, we canonicalize wildcards by enforcing the following invariants: <ol> <li>{@code canonicalize(t)} always produces the equal result for equivalent types. For example both {@code Enum<?>} and {@code Enum<? extends Enum<?>>} canonicalize to {@code Enum<? extends Enum<E>}. <li>{@code canonicalize(t)} produces a "literal" supertype of t. For example: {@code Enum<? extends Enum<?>>} canonicalizes to {@code Enum<?>}, which is a supertype (if we disregard the upper bound is implicitly an Enum too). <li>If {@code canonicalize(A) == canonicalize(B)}, then {@code Foo<A>.isSubtypeOf(Foo<B>)} and vice versa. i.e. {@code A.is(B)} and {@code B.is(A)}. <li>{@code canonicalize(canonicalize(A)) == canonicalize(A)}. </ol>
5 Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}. This is especially useful for command-line configuration of a {@code CacheBuilder}. @param spec a String in the format specified by {@link CacheBuilderSpec} @since 12.0
6 Returns a CacheBuilderSpec that will prevent caching.
7 Returns an instance of {@link InternetDomainName} after lenient validation. Specifically, validation against <a href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a> ("Internationalizing Domain Names in Applications") is skipped, while validation against <a href="http://www.ietf.org/rfc/rfc1035.txt">RFC 1035</a> is relaxed in the following ways: <ul> <li>Any part containing non-ASCII characters is considered valid. <li>Underscores ('_') are permitted wherever dashes ('-') are permitted. <li>Parts other than the final part may start with a digit, as mandated by <a href="https://tools.ietf.org/html/rfc1123#section-2">RFC 1123</a>. </ul> @param domain A domain name (not IP address) @throws IllegalArgumentException if {@code domain} is not syntactically valid according to {@link #isValid} @since 10.0 (previously named {@code fromLenient})
8 Returns a list of delegate futures that correspond to the futures received in the order that they complete. Delegate futures return the same value or throw the same exception as the corresponding input future returns/throws. <p>"In the order that they complete" means, for practical purposes, about what you would expect, but there are some subtleties. First, we do guarantee that, if the output future at index n is done, the output future at index n-1 is also done. (But as usual with futures, some listeners for future n may complete before some for future n-1.) However, it is possible, if one input completes with result X and another later with result Y, for Y to come before X in the output future list. (Such races are impossible to solve without global synchronization of all future completions. And they should have little practical impact.) <p>Cancelling a delegate future propagates to input futures once all the delegates complete, either from cancellation or because an input future has completed. If N futures are passed in, and M delegates are cancelled, the remaining M input futures will be cancelled once N - M of the input futures complete. If all the delegates are cancelled, all the input futures will be too. @since 17.0
9 Returns a new range set consisting of the union of this range set and {@code other}. <p>This is essentially the same as {@code TreeRangeSet.create(this).addAll(other)} except it returns an {@code ImmutableRangeSet}. @since 21.0
10 Returns an immutable multimap containing the same mappings as {@code multimap}, in the "key-grouped" iteration order described in the class documentation. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. @throws NullPointerException if any key or value in {@code multimap} is null
11 Returns a newly-created immutable list multimap.
12 Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result {@code ImmutableMap} in encounter order. <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}, an {@code IllegalArgumentException} is thrown when the collection operation is performed. (This differs from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.) @since 21.0
13 Returns an immutable multimap containing a single entry.
14 Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.
15 Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.
16 Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.
17 Returns an immutable multimap containing the given entries, in order. Repeated occurrences of an entry (according to {@link Object#equals}) after the first are ignored.
18 Returns an immutable multimap containing the specified entries. The returned multimap iterates over keys in the order they were first encountered in the input, and the values for each key are iterated in the order they were encountered. If two values for the same key are {@linkplain Object#equals equal}, the first value encountered is used. @throws NullPointerException if any key, value, or entry is null @since 19.0
19 Returns an immutable set multimap containing the same mappings as {@code multimap}. The generated multimap's key and value orderings correspond to the iteration ordering of the {@code multimap.asMap()} view. Repeated occurrences of an entry in the multimap after the first are ignored. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. @throws NullPointerException if any key or value in {@code multimap} is null
20 Returns a map with the given {@code values}, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying {@code keyFunction} to that value. These entries appear in the same order as the input values. Example usage: {@snippet : Color red = new Color("red", 255, 0, 0); ... ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue); ImmutableMap<String, Color> colorForName = uniqueIndex(allColors, c -> c.toString()); assertThat(colorForName).containsEntry("red", red); } <p>If your index may associate multiple values with each key, use {@link Multimaps#index(Iterable, Function) Multimaps.index}. <p><b>Note:</b> on Java 8+, it is usually better to use streams. For example: {@snippet : import static com.google.common.collect.ImmutableMap.toImmutableMap; ... ImmutableMap<String, Color> colorForName = allColors.stream().collect(toImmutableMap(c -> c.toString(), c -> c)); } <p>Streams provide a more standard and flexible API and the lambdas make it clear what the keys and values in the map are. @param values the values to use when constructing the {@code Map} @param keyFunction the function used to produce the key for each value @return a map mapping the result of evaluating the function {@code keyFunction} on each value in the input collection to that value @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one value in the input collection @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code keyFunction} produces {@code null} for any value
21 Creates an {@code ArrayTable} filled with {@code null}. @param rowKeys row keys that may be stored in the generated table @param columnKeys column keys that may be stored in the generated table @throws NullPointerException if any of the provided keys is null @throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys} contains duplicates or if exactly one of {@code rowKeys} or {@code columnKeys} is empty.
22 Returns the set of all possible subsets of {@code set}. For example, {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}. <p>Elements appear in these subsets in the same iteration order as they appeared in the input set. The order in which these subsets appear in the outer set is undefined. Note that the power set of the empty set is not the empty set, but a one-element set containing the empty set. <p>The returned set and its constituent sets use {@code equals} to decide whether two elements are identical, even if the input set uses a different concept of equivalence. <p><i>Performance notes:</i> while the power set of a set with size {@code n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set is merely copied. Only as the power set is iterated are the individual subsets created, and these subsets themselves occupy only a small constant amount of memory. @param set the set of elements to construct a power set from @return the power set, as an immutable set of immutable sets @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the power set size to exceed the {@code int} range) @throws NullPointerException if {@code set} is or contains {@code null} @see <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at Wikipedia</a> @since 4.0
23 A factory that chooses the most space-efficient representation of the table.
24 Returns a newly-created {@code ImmutableGraph} based on the contents of this {@code Builder}.
25 Returns an immutable copy of {@code network}.
26 Returns an immutable copy of {@code graph}.
27 Returns a resolver that resolves types "covariantly". <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code <T>} is covariantly resolved to {@code <?>} such that return type of {@code List::get} is {@code <?>}.
28 Returns a resolver that resolves types "invariantly". <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code <T>} cannot be invariantly resolved to {@code <?>} because otherwise the parameter type of {@code List::set} will be {@code <?>} and it'll falsely say any object can be passed into {@code ArrayList<?>::set}. <p>Instead, {@code <?>} will be resolved to a capture in the form of a type variable {@code <capture-of-? extends Object>}, effectively preventing {@code set} from accepting any type.
29 Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in {@code actual}. <p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination thereof. @param formal The type whose type variables or itself is mapped to other type(s). It's almost always a bug if {@code formal} isn't a type variable and contains no type variable. Make sure you are passing the two parameters in the right order. @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet other type variables, in which case these type variables will be further resolved if corresponding mappings exist in the current {@code TypeResolver} instance.
30 Returns an immutable map whose keys are the distinct elements of this {@code FluentIterable} and whose value for each key was computed by {@code valueFunction}. The map's iteration order is the order of the first appearance of each key in this iterable. <p>When there are multiple instances of a key in this iterable, it is unspecified whether {@code valueFunction} will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map. <p><b>{@code Stream} equivalent:</b> {@code stream.collect(ImmutableMap.toImmutableMap(k -> k, valueFunction))}. @throws NullPointerException if any element of this iterable is {@code null}, or if {@code valueFunction} produces {@code null} for any key @since 14.0
31 Builds a new min-max priority queue using the previously specified options, and having the given initial elements.
32 Adds the given element to this queue. If this queue has a maximum size, after adding {@code element} the queue will automatically evict its greatest element (according to its comparator), which may be {@code element} itself. @return {@code true} always
33 Returns all top level classes whose package name is {@code packageName}.
34 Returns all top level classes whose package name is {@code packageName} or starts with {@code packageName} followed by a '.'.
35 Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in the order of a breadth-first traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on. <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in the order {@code abcdef} (assuming successors are returned in alphabetical order). {@snippet : b ---- a ---- d | | | | e ---- c ---- f } <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change while iteration is in progress. <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will compute its next element on the fly. It is thus possible to limit the traversal to a certain number of nodes as follows: {@snippet : Iterables.limit(Traverser.forGraph(graph).breadthFirst(node), maxNumberOfNodes); } <p>See <a href="https://en.wikipedia.org/wiki/Breadth-first_search">Wikipedia</a> for more info. @throws IllegalArgumentException if {@code startNode} is not an element of the graph
36 Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in the order of a depth-first pre-order traversal. "Pre-order" implies that nodes appear in the {@code Iterable} in the order in which they are first visited. <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in the order {@code abecfd} (assuming successors are returned in alphabetical order). {@snippet : b ---- a ---- d | | | | e ---- c ---- f } <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change while iteration is in progress. <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will compute its next element on the fly. It is thus possible to limit the traversal to a certain number of nodes as follows: {@snippet : Iterables.limit( Traverser.forGraph(graph).depthFirstPreOrder(node), maxNumberOfNodes); } <p>See <a href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia</a> for more info. @throws IllegalArgumentException if {@code startNode} is not an element of the graph
37 Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in the order of a depth-first post-order traversal. "Post-order" implies that nodes appear in the {@code Iterable} in the order in which they are visited for the last time. <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in the order {@code fcebda} (assuming successors are returned in alphabetical order). {@snippet : b ---- a ---- d | | | | e ---- c ---- f } <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change while iteration is in progress. <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will compute its next element on the fly. It is thus possible to limit the traversal to a certain number of nodes as follows: {@snippet : Iterables.limit( Traverser.forGraph(graph).depthFirstPostOrder(node), maxNumberOfNodes); } <p>See <a href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia</a> for more info. @throws IllegalArgumentException if {@code startNode} is not an element of the graph
38 Scans this location and returns all scanned resources.
39 Returns a {@code ClassPath} representing all classes and resources loadable from {@code classloader} and its ancestor class loaders. <p><b>Warning:</b> {@code ClassPath} can find classes and resources only from: <ul> <li>{@link URLClassLoader} instances' {@code file:} URLs <li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code ClassPath} searches the files from the {@code java.class.path} system property. </ul> @throws IOException if the attempt to read class path resources (jar files or directories) failed.
40 Explicitly specifies the return type of this {@code Invokable}. For example: {@snippet : Method factoryMethod = Person.class.getMethod("create"); Invokable<?, Person> factory = Invokable.of(getNameMethod).returning(Person.class); }
