1 Drain the key and value reference queues, cleaning up internal entries containing garbage collected keys or values.
2 Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the bimap and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented at {@link Predicate#apply}. @since 14.0
3 Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the bimap and its views. When given a value that doesn't satisfy the predicate, the bimap's {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the predicate. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented at {@link Predicate#apply}. @since 14.0
4 Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. <p>This method is not type-safe, as it may be called on elements that are not mutually comparable. @throws ClassCastException if the elements are not mutually comparable @throws NullPointerException if any of {@code elements} is null
5 Returns the type token representing the generic type declaration of {@code cls}. For example: {@code TypeToken.getGenericType(Iterable.class)} returns {@code Iterable<T>}. <p>If {@code cls} isn't parameterized and isn't a generic array, the type token of the class is returned.
6 Returns an {@code ImmutableMultiset} containing all of the elements from this fluent iterable. <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableMultiset#toImmutableMultiset} to {@code stream.collect()}. @throws NullPointerException if any element is null @since 19.0
7 Returns a newly-created {@code ImmutableMultiset} based on the contents of the {@code Builder}.
8 Returns every possible list that can be formed by choosing one element from each of the given lists in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>" of the lists. For example: {@snippet : Lists.cartesianProduct(ImmutableList.of( ImmutableList.of(1, 2), ImmutableList.of("A", "B", "C"))) } <p>returns a list containing six lists in the following order: <ul> <li>{@code ImmutableList.of(1, "A")} <li>{@code ImmutableList.of(1, "B")} <li>{@code ImmutableList.of(1, "C")} <li>{@code ImmutableList.of(2, "A")} <li>{@code ImmutableList.of(2, "B")} <li>{@code ImmutableList.of(2, "C")} </ul> <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian products that you would get from nesting for loops: {@snippet : for (B b0 : lists.get(0)) { for (B b1 : lists.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple } } } <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a list of size {@code m x n x p}, its actual memory consumption is much smaller. When the cartesian product is constructed, the input lists are merely copied. Only as the resulting list is iterated are the individual lists created, and these are not retained after iteration. @param lists the lists to choose elements from, in the order that the elements chosen from those lists should appear in the resulting lists @param <B> any common base class shared by all axes (often just {@link Object}) @return the Cartesian product, as an immutable list containing immutable lists @throws IllegalArgumentException if the size of the cartesian product would be greater than {@link Integer#MAX_VALUE} @throws NullPointerException if {@code lists}, any one of the {@code lists}, or any element of a provided list is null @since 19.0
9 Creates a CacheBuilderSpec from a string. @param cacheBuilderSpecification the string form
10 Returns an {@code ImmutableList} containing all of the elements from this fluent iterable in proper sequence. <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableList#toImmutableList} to {@code stream.collect()}. @throws NullPointerException if any element is {@code null} @since 14.0 (since 12.0 as {@code toImmutableList()}).
11 Returns an immutable list of paths to the files contained in the given directory. @throws NoSuchFileException if the file does not exist <i>(optional specific exception)</i> @throws NotDirectoryException if the file could not be opened because it is not a directory <i>(optional specific exception)</i> @throws IOException if an I/O error occurs
12 Constructor used to implement {@link #from(String)}, and from subclasses.
13 Creates a new {@code ListenableFuture} whose value is a list containing the values of all its input futures, if all succeed. <p>The list of results is in the same order as the input list. <p>This differs from {@link #successfulAsList(Iterable)} in that it will return a failed future if any of the items fails. <p>Canceling this future will attempt to cancel all the component futures, and if any of the provided futures fails or is canceled, this one is, too. @param futures futures to combine @return a future that provides a list of the results of the component futures @since 10.0
14 Creates a {@link FutureCombiner} that processes the completed futures whether or not they're successful. <p>Any failures from the input futures will not be propagated to the returned future. @since 20.0
15 Creates a {@link FutureCombiner} requiring that all passed in futures are successful. <p>If any input fails, the returned future fails immediately. @since 20.0
16 Creates a new {@code ListenableFuture} whose value is a list containing the values of all its successful input futures. The list of results is in the same order as the input list, and if any of the provided futures fails or is canceled, its corresponding position will contain {@code null} (which is indistinguishable from the future having a successful value of {@code null}). <p>The list of results is in the same order as the input list. <p>This differs from {@link #allAsList(Iterable)} in that it's tolerant of failed futures for any of the items, representing them as {@code null} in the result list. <p>Canceling this future will attempt to cancel all the component futures. @param futures futures to combine @return a future that provides a list of the results of the component futures @since 10.0
17 Can't use Iterables.toArray because it's not gwt compatible
18 Returns an {@code ImmutableRangeSet} representing the union of the specified ranges. <p>This is the smallest {@code RangeSet} which encloses each of the specified ranges. Duplicate or connected ranges are permitted, and will be coalesced in the result. @since 21.0
19 Returns a new range set consisting of the intersection of this range set and {@code other}. <p>This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other.complement())} except it returns an {@code ImmutableRangeSet}. @since 21.0
20 Returns a new range set consisting of the difference of this range set and {@code other}. <p>This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other)} except it returns an {@code ImmutableRangeSet}. @since 21.0
21 Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys and values are the result of applying the provided mapping functions to the input elements. Entries appear in the result {@code ImmutableBiMap} in encounter order. <p>If the mapped keys or values contain duplicates (according to {@link Object#equals(Object)}), an {@code IllegalArgumentException} is thrown when the collection operation is performed. (This differs from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.) @since 21.0
22 Returns an immutable map containing the same entries as {@code map}. If {@code map} somehow contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose comparator is not <i>consistent with equals</i>), the results of this method are undefined. <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an {@code ImmutableClassToInstanceMap}, no copy will actually be performed. @throws NullPointerException if any key or value in {@code map} is null @throws ClassCastException if any value is not an instance of the type specified by its key
23 Returns an immutable multimap containing the same mappings as {@code multimap}. The generated multimap's key and value orderings correspond to the iteration ordering of the {@code multimap.asMap()} view. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. @throws NullPointerException if any key or value in {@code multimap} is null
24 Returns a newly-created immutable multimap.
25 @since 28.1
26 Returns a newly-created immutable set multimap.
27 Returns a map with the given {@code values}, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying {@code keyFunction} to that value. These entries appear in the same order as the input values. Example usage: {@snippet : Color red = new Color("red", 255, 0, 0); ... Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator(); Map<String, Color> colorForName = uniqueIndex(allColors, toStringFunction()); assertThat(colorForName).containsEntry("red", red); } <p>If your index may associate multiple values with each key, use {@link Multimaps#index(Iterator, Function) Multimaps.index}. @param values the values to use when constructing the {@code Map} @param keyFunction the function used to produce the key for each value @return a map mapping the result of evaluating the function {@code keyFunction} on each value in the input collection to that value @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one value in the input collection @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code keyFunction} produces {@code null} for any value @since 10.0
28 Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}. <p>Elements appear in these subsets in the same iteration order as they appeared in the input set. The order in which these subsets appear in the outer set is undefined. <p>The returned set and its constituent sets use {@code equals} to decide whether two elements are identical, even if the input set uses a different concept of equivalence. <p><i>Performance notes:</i> the memory usage of the returned set is only {@code O(n)}. When the result set is constructed, the input set is merely copied. Only as the result set is iterated are the individual subsets created. Each of these subsets occupies an additional O(n) memory but only for as long as the user retains a reference to it. That is, the set returned by {@code combinations} does not retain the individual subsets. @param set the set of elements to take combinations of @param size the number of elements per combination @return the set of all combinations of {@code size} elements from {@code set} @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()} inclusive @throws NullPointerException if {@code set} is or contains {@code null} @since 23.0
29 Returns an immutable copy of {@code graph}.
30 Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}.
31 Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value for each key was computed by {@code valueFunction}. The map's iteration order is the order of the first appearance of each key in {@code keys}. <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code valueFunction} will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map. <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of a copy using {@link Maps#asMap(Set, Function)}. <p><b>Note:</b> on Java 8+, it is usually better to use streams. For example: {@snippet : import static com.google.common.collect.ImmutableMap.toImmutableMap; ... ImmutableMap<Color, String> colorNames = allColors.stream().collect(toImmutableMap(c -> c, c -> c.toString())); } <p>Streams provide a more standard and flexible API and the lambdas make it clear what the keys and values in the map are. @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code valueFunction} produces {@code null} for any key @since 14.0
32 Removes and returns the least element of this queue, or returns {@code null} if the queue is empty.
33 Adds the given element to this queue. If this queue has a maximum size, after adding {@code element} the queue will automatically evict its greatest element (according to its comparator), which may be {@code element} itself.
34 Returns all classes loadable from the current class path. @since 16.0
35 Returns all top level classes loadable from the current class path. Note that "top-level-ness" is determined heuristically by class name (see {@link ClassInfo#isTopLevel}).
36 Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first traversal of a graph with an additional root node whose successors are the listed {@code startNodes}. @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph @see #breadthFirst(Object) @since 24.1
37 Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a depth-first pre-order traversal of a graph with an additional root node whose successors are the listed {@code startNodes}. @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph @see #depthFirstPreOrder(Object) @since 24.1
38 Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a depth-first post-order traversal of a graph with an additional root node whose successors are the listed {@code startNodes}. @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph @see #depthFirstPostOrder(Object) @since 24.1
39 Scans this location and returns all scanned resources. <p>This file and jar files from "Class-Path" entry in the scanned manifest files will be added to {@code scannedFiles}. <p>A file will be scanned at most once even if specified multiple times by one or multiple jar files' "Class-Path" manifest entries. Particularly, if a jar file from the "Class-Path" manifest entry is already in {@code scannedFiles}, either because it was scanned earlier, or it was intentionally added to the set by the caller, it will not be scanned again. <p>Note that when you call {@code location.scanResources(scannedFiles)}, the location will always be scanned even if {@code scannedFiles} already contains it.
40 Explicitly specifies the return type of this {@code Invokable}.
