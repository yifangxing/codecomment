1 Gets the value from an entry. Returns null if the entry is invalid, partially-collected, loading, or expired.
2 Performs routine cleanup prior to executing a write. This should be called every time a write thread acquires the segment lock, immediately after acquiring the lock. <p>Post-condition: expireEntries has been run.
3 Resolves {@code var} using the encapsulated type mapping. If it maps to yet another non-reified type or has bounds, {@code forDependants} is used to do further resolution, which doesn't try to resolve any type variable on generic declarations that are already being resolved. <p>Should only be called and overridden by {@link #resolve(TypeVariable)}.
4 If the class is parameterized, such as {@link java.util.ArrayList ArrayList}, this returns {@code ArrayList<E>}.
5 Implemented to support serialization of subclasses.
6 Returns a {@link Traverser} instance for the file and directory tree. The returned traverser starts from a {@link Path} and will return all files and directories it encounters. <p>The returned traverser attempts to avoid following symbolic links to directories. However, the traverser cannot guarantee that it will not follow symbolic links to directories as it is possible for a directory to be replaced with a symbolic link between checking if the file is a directory and actually reading the contents of that directory. <p>If the {@link Path} passed to one of the traversal methods does not exist or is not a directory, no exception will be thrown and the returned {@link Iterable} will contain a single element: that path. <p>{@link DirectoryIteratorException} may be thrown when iterating {@link Iterable} instances created by this traverser if an {@link IOException} is thrown by a call to {@link #listFiles(Path)}. <p>Example: {@code MoreFiles.fileTraverser().depthFirstPreOrder(Paths.get("/"))} may return the following paths: {@code ["/", "/etc", "/etc/config.txt", "/etc/fonts", "/home", "/home/alice", ...]} @since 23.5
7 Returns a {@code HostSpecifier} built from the provided {@code specifier}, which is already known to be valid. If the {@code specifier} might be invalid, use {@link #from(String)} instead. <p>The specifier must be in one of these formats: <ul> <li>A domain name, like {@code google.com} <li>A IPv4 address string, like {@code 127.0.0.1} <li>An IPv6 address string with or without brackets, like {@code [2001:db8::1]} or {@code 2001:db8::1} </ul> @throws IllegalArgumentException if the specifier is not valid.
8 Returns the ancestor of the current domain at the given number of levels "higher" (rightward) in the subdomain list. The number of levels must be non-negative, and less than {@code N-1}, where {@code N} is the number of parts in the domain. <p>TODO: Reasonable candidate for addition to public API.
9 Creates and returns a new {@code InternetDomainName} by prepending the argument and a dot to the current name. For example, {@code InternetDomainName.from("foo.com").child("www.bar")} returns a new {@code InternetDomainName} with the value {@code www.bar.foo.com}. Only lenient validation is performed, as described {@link #from(String) here}. @throws NullPointerException if leftParts is null @throws IllegalArgumentException if the resulting name is not valid
10 Indicates whether the argument is a syntactically valid domain name using lenient validation. Specifically, validation against <a href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a> ("Internationalizing Domain Names in Applications") is skipped. <p>The following two code snippets are equivalent: {@snippet : domainName = InternetDomainName.isValid(name) ? InternetDomainName.from(name) : DEFAULT_DOMAIN; } {@snippet : try { domainName = InternetDomainName.from(name); } catch (IllegalArgumentException e) { domainName = DEFAULT_DOMAIN; } } @since 8.0 (previously named {@code isValidLenient})
11 Returns a {@code Collector} accumulating entries into an {@code ImmutableListMultimap}. Each input element is mapped to a key and a stream of values, each of which are put into the resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the streams of values. <p>Example: {@snippet : static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP = Stream.of("banana", "apple", "carrot", "asparagus", "cherry") .collect( flatteningToImmutableListMultimap( str -> str.charAt(0), str -> str.substring(1).chars().mapToObj(c -> (char) c)); // is equivalent to static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP = ImmutableListMultimap.<Character, Character>builder() .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a')) .putAll('a', Arrays.asList('p', 'p', 'l', 'e')) .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't')) .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's')) .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y')) .build(); } } @since 21.0
12 Returns an immutable multimap containing a single entry.
13 Returns an immutable multimap containing the given entries, in order.
14 Returns an immutable multimap containing the given entries, in order.
15 Returns an immutable multimap containing the given entries, in order.
16 Returns an immutable multimap containing the given entries, in order.
17 Returns an immutable multimap containing the specified entries. The returned multimap iterates over keys in the order they were first encountered in the input, and the values for each key are iterated in the order they were encountered. @throws NullPointerException if any key, value, or entry is null @since 19.0
18 Creates an index {@code ImmutableListMultimap} that contains the results of applying a specified function to each item in an {@code Iterator} of values. Each value will be stored as a value in the resulting multimap, yielding a multimap with the same size as the input iterator. The key used to store that value in the multimap will be the result of calling the function on that value. The resulting multimap is created as an immutable snapshot. In the returned multimap, keys appear in the order they are first encountered, and the values corresponding to each key appear in the same order as they are encountered. <p>For example, {@snippet : List<String> badGuys = Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde"); Function<String, Integer> stringLengthFunction = ...; Multimap<Integer, String> index = Multimaps.index(badGuys.iterator(), stringLengthFunction); System.out.println(index); } <p>prints {@snippet : {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]} } <p>The returned multimap is serializable if its keys and values are all serializable. @param values the values to use when constructing the {@code ImmutableListMultimap} @param keyFunction the function used to produce the key for each value @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code keyFunction} on each value in the input collection to that value @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code keyFunction} produces {@code null} for any key @since 10.0
19 <em>Replaces</em> all parameters with the given attribute with parameters using the given values. If there are no values, any existing parameters with the given attribute are removed. @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid @since 24.0
20 Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>For streams with defined encounter order (as defined in the Ordering section of the {@link java.util.stream} Javadoc), that order is preserved, but entries are <a href="ImmutableMultimap.html#iteration">grouped by key</a>. <p>Example: {@snippet : static final Multimap<Character, String> FIRST_LETTER_MULTIMAP = Stream.of("banana", "apple", "carrot", "asparagus", "cherry") .collect(toImmutableSetMultimap(str -> str.charAt(0), str -> str.substring(1))); // is equivalent to static final Multimap<Character, String> FIRST_LETTER_MULTIMAP = new ImmutableSetMultimap.Builder<Character, String>() .put('b', "anana") .putAll('a', "pple", "sparagus") .putAll('c', "arrot", "herry") .build(); } @since 21.0
21 {@inheritDoc} <p>Because an inverse of a set multimap cannot contain multiple pairs with the same key and value, this method returns an {@code ImmutableSetMultimap} rather than the {@code ImmutableMultimap} specified in the {@code ImmutableMultimap} class.
22 Marks the {@link State} as ready to receive transitions. Returns true if no transitions have been observed yet.
23 Provides a snapshot of the current state of all the services under management. <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will correspond to a point in time view of the services. @since 29.0 (present with return type {@code ImmutableMultimap} since 14.0)
24 Returns a map with the contents of this {@code FluentIterable} as its {@code values}, indexed by keys derived from those values. In other words, each input value produces an entry in the map whose key is the result of applying {@code keyFunction} to that value. These entries appear in the same order as they appeared in this fluent iterable. Example usage: {@snippet : Color red = new Color("red", 255, 0, 0); ... FluentIterable<Color> allColors = FluentIterable.from(ImmutableSet.of(red, green, blue)); Map<String, Color> colorForName = allColors.uniqueIndex(toStringFunction()); assertThat(colorForName).containsEntry("red", red); } <p>If your index may associate multiple values with each key, use {@link #index(Function) index}. <p><b>{@code Stream} equivalent:</b> {@code stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -> v))}. @param keyFunction the function used to produce the key for each value @return a map mapping the result of evaluating the function {@code keyFunction} on each value in this fluent iterable to that value @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one value in this fluent iterable @throws NullPointerException if any element of this iterable is {@code null}, or if {@code keyFunction} produces {@code null} for any key @since 14.0
25 Creates an {@code ArrayTable} with the mappings in the provided table. <p>If {@code table} includes a mapping with row key {@code r} and a separate mapping with column key {@code c}, the returned table contains a mapping with row key {@code r} and column key {@code c}. If that row key / column key pair in not in {@code table}, the pair maps to {@code null} in the generated table. <p>The returned table allows subsequent {@code put} calls with the row keys in {@code table.rowKeySet()} and the column keys in {@code table.columnKeySet()}. Calling {@link #put} with other keys leads to an {@code IllegalArgumentException}. <p>The ordering of {@code table.rowKeySet()} and {@code table.columnKeySet()} determines the row and column iteration ordering of the returned table. @throws NullPointerException if {@code table} has a null key
26 Returns a newly-created {@code ImmutableNetwork} based on the contents of this {@code Builder}.
27 Returns a newly-created {@code ImmutableValueGraph} based on the contents of this {@code Builder}.
28 Constructs a new type token of {@code T} while resolving free type variables in the context of {@code declaringClass}. <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure. <p>For example: {@snippet : abstract class IKnowMyType<T> { TypeToken<T> getMyType() { return new TypeToken<T>(getClass()) {}; } } new IKnowMyType<String>() {}.getMyType() => String }
29 Builds a new min-max priority queue using the previously specified options, and having no initial contents.
30 Creates a new min-max priority queue using natural order, no maximum size, and initially containing the given elements.
31 Returns the set of nodes that are reachable from {@code node}. Node B is defined as reachable from node A if there exists a path (a sequence of adjacent outgoing edges) starting at node A and ending at node B. Note that a node is always reachable from itself via a zero-length path. <p>This is a "snapshot" based on the current topology of {@code graph}, rather than a live view of the set of nodes reachable from {@code node}. In other words, the returned {@link Set} will not be updated after modifications to {@code graph}. @throws IllegalArgumentException if {@code node} is not present in {@code graph} @since 33.1.0 (present with return type {@code Set} since 20.0)
