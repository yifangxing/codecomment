1 Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application is complete. It does so by using daemon threads and adding a shutdown hook to wait for their completion. <p>This method waits 120 seconds before continuing with JVM termination, even if the executor has not finished its work. <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}. @param executor the executor to modify to make sure it exits when the application is finished @return an unmodifiable version of the input which will not hang the JVM
2 Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application is complete. It does so by using daemon threads and adding a shutdown hook to wait for their completion. <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}. @param executor the executor to modify to make sure it exits when the application is finished @param terminationTimeout how long to wait for the executor to finish before terminating the JVM @return an unmodifiable version of the input which will not hang the JVM @since 28.0 (but only since 33.4.0 in the Android flavor)
3 Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when the application is complete. It does so by using daemon threads and adding a shutdown hook to wait for their completion. <p>This method waits 120 seconds before continuing with JVM termination, even if the executor has not finished its work. <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}. @param executor the executor to modify to make sure it exits when the application is finished @return an unmodifiable version of the input which will not hang the JVM
4 Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when the application is complete. It does so by using daemon threads and adding a shutdown hook to wait for their completion. <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}. @param executor the executor to modify to make sure it exits when the application is finished @param terminationTimeout how long to wait for the executor to finish before terminating the JVM @return an unmodifiable version of the input which will not hang the JVM @since 28.0 (but only since 33.4.0 in the Android flavor)
5 Performs eviction if the segment is over capacity. Avoids flushing the entire cache if the newest entry exceeds the maximum weight all on its own. @param newest the most recently added entry
6 Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more than the given time. The manager will become healthy after all the component services have reached the {@linkplain State#RUNNING running} state. @param timeout the maximum time to wait @throws TimeoutException if not all of the services have finished starting within the deadline @throws IllegalStateException if the service manager reaches a state from which it cannot become {@linkplain #isHealthy() healthy}. @since 28.0 (but only since 33.4.0 in the Android flavor)
7 Returns the service load times. This value will only return startup times for services that have finished starting. @return Map of services and their corresponding startup time, the map entries will be ordered by startup time. @since 31.0 (but only since 33.4.0 in the Android flavor)
8 @since 18.0
9 Equivalent to {@code newReentrantLock(lockName, false)}.
10 Equivalent to {@code newReentrantReadWriteLock(lockName, false)}.
11 Validation method used by {@code from} to ensure that the domain name is syntactically valid according to RFC 1035. @return Is the domain name syntactically valid?
12 Registers all subscriber methods on the given listener object.
13 Unregisters all subscribers on the given listener object.
14 Returns an {@link ImmutableNetwork.Builder} with the properties of this {@link NetworkBuilder}. <p>The returned builder can be used for populating an {@link ImmutableNetwork}. @since 28.0
15 Returns the subgraph of {@code graph} induced by {@code nodes}. This subgraph is a new graph that contains all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges} from {@code graph} for which both nodes are contained by {@code nodes}. @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph
16 Creates a mutable copy of {@code graph} with the same nodes and edges.
17 Returns an {@link ImmutableValueGraph.Builder} with the properties of this {@link ValueGraphBuilder}. <p>The returned builder can be used for populating an {@link ImmutableValueGraph}. <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link ElementOrder#stable()}, regardless of the value that was set in this builder. @since 28.0
18 Support {@code clear()}, {@code removeAll()}, and {@code retainAll()} when filtering a filtered map.
19 Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method that throws an {@link IllegalArgumentException} when the existing key and the provided value don't satisfy the predicate. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. @since 14.0
20 Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method that throws an {@link IllegalArgumentException} when the existing key and the provided value don't satisfy the predicate. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings that satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. @since 11.0
21 Returns a map containing the mappings in {@code unfiltered} whose values satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()}, {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.
22 Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}), the values are merged using the specified merging function. If the merging function returns {@code null}, then the collector removes the value that has been computed for the key thus far (though future occurrences of the key would reinsert it). <p>Entries will appear in the encounter order of the first occurrence of the key. @since 21.0
23 Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableRangeMap}. As in {@link Builder}, overlapping ranges are not permitted. @since 23.1
24 Returns an immutable sorted multiset containing the given elements sorted by their natural ordering. To create a copy of a {@code SortedMultiset} that preserves the comparator, call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once. <p>Note that if {@code s} is a {@code Multiset<String>}, then {@code ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>} containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)} returns an {@code ImmutableSortedMultiset<Multiset<String>>} containing one element (the given multiset itself). <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. <p>This method is not type-safe, as it may be called on elements that are not mutually comparable. @throws ClassCastException if the elements are not mutually comparable @throws NullPointerException if any of {@code elements} is null
25 Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code Builder}.
26 Returns a new {@link WildcardType} with {@code upperBound}.
27 Returns a new {@link WildcardType} with {@code lowerBound}.
28 Returns a {@link Collection} of all the permutations of the specified {@link Iterable} using the specified {@link Comparator} for establishing the lexicographical ordering. <p>Examples: {@snippet : for (List<String> perm : orderedPermutations(asList("b", "c", "a"))) { println(perm); } // -> ["a", "b", "c"] // -> ["a", "c", "b"] // -> ["b", "a", "c"] // -> ["b", "c", "a"] // -> ["c", "a", "b"] // -> ["c", "b", "a"] for (List<Integer> perm : orderedPermutations(asList(1, 2, 2, 1))) { println(perm); } // -> [1, 1, 2, 2] // -> [1, 2, 1, 2] // -> [1, 2, 2, 1] // -> [2, 1, 1, 2] // -> [2, 1, 2, 1] // -> [2, 2, 1, 1] } <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the first permutation will be in ascending order, and the last will be in descending order. <p>Elements that compare equal are considered equal and no new permutations are created by swapping them. <p>An empty iterable has only one permutation, which is an empty list. @param elements the original iterable whose elements have to be permuted. @param comparator a comparator for the iterable's elements. @return an immutable {@link Collection} containing all the different permutations of the original iterable. @throws NullPointerException If the specified iterable is null, has any null elements, or if the specified comparator is null. @since 12.0
29 Returns an {@code ImmutableList} containing all of the elements from this {@code FluentIterable} in the order specified by {@code comparator}. To produce an {@code ImmutableList} sorted by its natural ordering, use {@code toSortedList(Ordering.natural())}. <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableList#toImmutableList} to {@code stream.sorted(comparator).collect()}. @param comparator the function by which to sort list elements @throws NullPointerException if any element of this iterable is {@code null} @since 14.0 (since 13.0 as {@code toSortedImmutableList()}).
30 Returns an immutable list containing the given elements, in order. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. <p>Note that if {@code list} is a {@code List<String>}, then {@code ImmutableList.copyOf(list)} returns an {@code ImmutableList<String>} containing each of the strings in {@code list}, while {@code ImmutableList.of(list)} returns an {@code ImmutableList<List<String>>} containing one element (the given list itself). <p>This method is safe to use even when {@code elements} is a synchronized or concurrent collection that is currently being modified by another thread. @throws NullPointerException if {@code elements} contains a null element
31 Returns a newly-created immutable bimap. The iteration order of the returned bimap is the order in which entries were inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case entries are sorted by value. <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method will throw an exception if there are duplicate keys or values. The {@code build()} method will soon be deprecated. @throws IllegalArgumentException if duplicate keys or values were added
32 Returns a newly-created immutable map, or throws an exception if any key was added more than once. The iteration order of the returned map is the order in which entries were inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case entries are sorted by value. @throws IllegalArgumentException if duplicate keys were added @since 31.0
33 Returns a newly-created immutable map, using the last value for any key that was added more than once. The iteration order of the returned map is the order in which entries were inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case entries are sorted by value. If a key was added more than once, it appears in iteration order based on the first time it was added, again unless {@link #orderEntriesByValue} was called. <p>In the current implementation, all values associated with a given key are stored in the {@code Builder} object, even though only one of them will be used in the built map. If there can be many repeated keys, it may be more space-efficient to use a {@link java.util.LinkedHashMap LinkedHashMap} and {@link ImmutableMap#copyOf(Map)} rather than {@code ImmutableMap.Builder}. @since 31.1
34 This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are less than {@code toKey}. <p>The {@link SortedMap#headMap} documentation states that a submap of a submap throws an {@link IllegalArgumentException} if passed a {@code toKey} greater than an earlier {@code toKey}. However, this method doesn't throw an exception in that situation, but instead keeps the original {@code toKey}.
35 This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys ranges from {@code fromKey} to {@code toKey}, inclusive or exclusive as indicated by the boolean flags. <p>The {@link SortedMap#subMap} documentation states that a submap of a submap throws an {@link IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}. However, this method doesn't throw an exception in that situation, but instead keeps the original {@code fromKey}. Similarly, this method keeps the original {@code toKey}, instead of throwing an exception, if passed a {@code toKey} greater than an earlier {@code toKey}. @since 12.0
36 This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are greater than or equals to {@code fromKey}. <p>The {@link SortedMap#tailMap} documentation states that a submap of a submap throws an {@link IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}. However, this method doesn't throw an exception in that situation, but instead keeps the original {@code fromKey}.
37 Returns an immutable map containing the given entries, with keys sorted by their natural ordering. <p>This method is not type-safe, as it may be called on a map with keys that are not mutually comparable. @throws NullPointerException if any key or value in {@code map} is null @throws IllegalArgumentException if any two keys are equal according to the comparator @since 19.0
38 Returns an immutable map containing the same entries as {@code map}, sorted by the natural ordering of the keys. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. <p>This method is not type-safe, as it may be called on a map with keys that are not mutually comparable. @throws ClassCastException if the keys in {@code map} are not mutually comparable @throws NullPointerException if any key or value in {@code map} is null @throws IllegalArgumentException if any two keys are equal according to their natural ordering
39 Returns an immutable map containing the same entries as {@code map}, with keys sorted by the provided comparator. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. @throws NullPointerException if any key or value in {@code map} is null @throws IllegalArgumentException if any two keys are equal according to the comparator
40 Returns every possible list that can be formed by choosing one element from each of the given sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>" of the sets. For example: {@snippet : Sets.cartesianProduct(ImmutableList.of( ImmutableSet.of(1, 2), ImmutableSet.of("A", "B", "C"))) } <p>returns a set containing six lists: <ul> <li>{@code ImmutableList.of(1, "A")} <li>{@code ImmutableList.of(1, "B")} <li>{@code ImmutableList.of(1, "C")} <li>{@code ImmutableList.of(2, "A")} <li>{@code ImmutableList.of(2, "B")} <li>{@code ImmutableList.of(2, "C")} </ul> <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian products that you would get from nesting for loops: {@snippet : for (B b0 : sets.get(0)) { for (B b1 : sets.get(1)) { ... ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...); // operate on tuple } } } <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at all are provided (an empty list), the resulting Cartesian product has one element, an empty list (counter-intuitive, but mathematically consistent). <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a set of size {@code m x n x p}, its actual memory consumption is much smaller. When the cartesian set is constructed, the input sets are merely copied. Only as the resulting set is iterated are the individual lists created, and these are not retained after iteration. @param sets the sets to choose elements from, in the order that the elements chosen from those sets should appear in the resulting lists @param <B> any common base class shared by all axes (often just {@link Object}) @return the Cartesian product, as an immutable set containing immutable lists @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a provided set is null @throws IllegalArgumentException if the cartesian product size exceeds the {@code int} range @since 2.0
41 Removes only this exact instance, not others that are equals()
42 Removes and returns the value at {@code index}.
43 Returns an immutable set containing each of {@code elements}, minus duplicates, in the order each appears first in the source iterable. This method iterates over {@code elements} only once. <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only once. This reduces the expense of habitually making defensive copies at API boundaries. However, the precise conditions for skipping the copy operation are undefined. @throws NullPointerException if any of {@code elements} is null
44 Returns the {@link Invokable} for {@code constructor}, which must be a member of {@code T}. @since 14.0
45 Returns true if this type is a subtype of the given {@code type}. "Subtype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type arguments</a> introduced with Java generics. @since 19.0
46 Returns the {@link Invokable} for {@code method}, which must be a member of {@code T}. @since 14.0
