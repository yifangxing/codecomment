1 Cleanup expired entries when the lock is available.
2 Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.
3 Registers all subscriber methods on {@code object} to receive events. @param object object whose subscriber methods should be registered.
4 Unregisters all subscriber methods on a registered {@code object}. @param object object whose subscriber methods should be unregistered. @throws IllegalArgumentException if the object was not previously registered.
5 Returns an {@link ImmutableGraph.Builder} with the properties of this {@link GraphBuilder}. <p>The returned builder can be used for populating an {@link ImmutableGraph}. <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link ElementOrder#stable()}, regardless of the value that was set in this builder. @since 28.0
6 Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The returned bimap is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the bimap and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method that throws an {@link IllegalArgumentException} when the existing key and the provided value don't satisfy the predicate. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered bimap or its views, only mappings that satisfy the filter will be removed from the underlying bimap. <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value mapping in the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy. <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented at {@link Predicate#apply}. @since 14.0
7 Returns a navigable map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. @since 14.0
8 Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()}, {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. @since 14.0
9 Returns a sorted map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings whose keys satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. @since 11.0
10 Returns a sorted map containing the mappings in {@code unfiltered} whose values satisfy a predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the other. <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have iterators that don't support {@code remove()}, but all other methods are supported by the map and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()}, {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}. <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map or its views, only mappings whose values satisfy the filter will be removed from the underlying map. <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is. <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value mapping in the underlying map and determine which satisfy the filter. When a live view is <i>not</i> needed, it may be faster to copy the filtered map and use the copy. <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented at {@link Predicate#apply}. Do not provide a predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. @since 11.0
11 Returns an immutable sorted multiset containing the given elements sorted by the given {@code Comparator}. @throws NullPointerException if {@code comparator} or any of {@code elements} is null
12 Returns all locations that {@code classloader} and parent loaders load classes and resources from. Callers can {@linkplain LocationInfo#scanResources scan} individual locations selectively or even in parallel.
13 Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null otherwise.
14 Returns the array type of {@code componentType}.
15 Returns a {@link Collection} of all the permutations of the specified {@link Iterable}. <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the first permutation will be in ascending order, and the last will be in descending order. <p>Duplicate elements are considered equal. For example, the list [1, 1] will have only one permutation, instead of two. This is why the elements have to implement {@link Comparable}. <p>An empty iterable has only one permutation, which is an empty list. <p>This method is equivalent to {@code Collections2.orderedPermutations(list, Ordering.natural())}. @param elements the original iterable whose elements have to be permuted. @return an immutable {@link Collection} containing all the different permutations of the original iterable. @throws NullPointerException if the specified iterable is null or has any null elements. @since 12.0
16 Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. @throws NullPointerException if any of {@code elements} is null
17 Returns an immutable multiset containing the given elements, in the "grouped iteration order" described in the class documentation. @throws NullPointerException if any of {@code elements} is null
18 Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order puts the highest count first, with ties broken by the iteration order of the original multiset. @since 11.0
19 Returns a {@link Collection} of all the permutations of the specified {@link Collection}. <p><i>Notes:</i> This is an implementation of the Plain Changes algorithm for permutations generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. <p>If the input list contains equal elements, some of the generated permutations will be equal. <p>An empty collection has only one permutation, which is an empty list. @param elements the original collection whose elements have to be permuted. @return an immutable {@link Collection} containing all the different permutations of the original collection. @throws NullPointerException if the specified collection is null or has any null elements. @since 12.0
20 Returns an immutable list containing the given elements, in order. If {@code elements} is a {@link Collection}, this method behaves exactly as {@link #copyOf(Collection)}; otherwise, it behaves exactly as {@code copyOf(elements.iterator()}. @throws NullPointerException if {@code elements} contains a null element
21 Returns an immutable copy of the specified {@code RangeSet}.
22 Returns an immutable sorted set containing the elements of a sorted set, sorted by the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always uses the natural ordering of the elements. <p>Despite the method name, this method attempts to avoid actually copying the data when it is safe to do so. The exact circumstances under which a copy will or will not be performed are undocumented and subject to change. <p>This method is safe to use even when {@code sortedSet} is a synchronized or concurrent collection that is currently being modified by another thread. @throws NullPointerException if {@code sortedSet} or any of its elements is null
23 Reads all the lines of this source as a list of strings. The returned list will be empty if this source is empty. <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code \n}. If the source's content does not end in a line termination sequence, it is treated as if it does. @throws IOException if an I/O error occurs while reading from this source
24 Returns a new immutable class-to-instance map containing the entries provided to this builder. @throws IllegalArgumentException if duplicate keys were added
25 Creates an ImmutableListMultimap from an asMap.entrySet.
26 Returns a newly-created immutable map. The iteration order of the returned map is the order in which entries were inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case entries are sorted by value. <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method will throw an exception if there are duplicate keys. The {@code build()} method will soon be deprecated. @throws IllegalArgumentException if duplicate keys were added
27 Creates an ImmutableSetMultimap from an asMap.entrySet.
28 Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}. @param properties a {@code Properties} object to be converted @return an immutable map containing all the entries in {@code properties} @throws ClassCastException if any key in {@code properties} is not a {@code String} @throws NullPointerException if any key or value in {@code properties} is null
29 Returns a map from the ith element of list to i.
30 Returns a new immutable type-to-instance map containing the entries provided to this builder. @throws IllegalArgumentException if duplicate keys were added
31 Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}.
32 Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value for each key was computed by {@code valueFunction}. The map's iteration order is the order of the first appearance of each key in {@code keys}. <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code valueFunction} will be applied to more than one instance of that key and, if it is, which result will be mapped to that key in the returned map. @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code valueFunction} produces {@code null} for any key @since 14.0
33 This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys ranges from {@code fromKey}, inclusive, to {@code toKey}, exclusive. <p>The {@link SortedMap#subMap} documentation states that a submap of a submap throws an {@link IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}. However, this method doesn't throw an exception in that situation, but instead keeps the original {@code fromKey}. Similarly, this method keeps the original {@code toKey}, instead of throwing an exception, if passed a {@code toKey} greater than an earlier {@code toKey}.
34 Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap} whose keys and values are the result of applying the provided mapping functions to the input elements. <p>If the mapped keys contain duplicates (according to the comparator), the values are merged using the specified merging function. Entries will appear in the encounter order of the first occurrence of the key. @since 21.0
35 Removes and returns the greatest element of this queue, or returns {@code null} if the queue is empty.
36 Removes and returns the greatest element of this queue. @throws NoSuchElementException if the queue is empty
37 Returns an {@code ImmutableSet} containing all of the elements from this fluent iterable with duplicates removed. <p><b>{@code Stream} equivalent:</b> pass {@link ImmutableSet#toImmutableSet} to {@code stream.collect()}. @throws NullPointerException if any element is {@code null} @since 14.0 (since 12.0 as {@code toImmutableSet()}).
38 Returns true if this type is a supertype of the given {@code type}. "Supertype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type arguments</a> introduced with Java generics. @since 19.0
39 Returns true if this type is a supertype of the given {@code type}. "Supertype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type arguments</a> introduced with Java generics. @since 19.0
40 Returns true if this type is a subtype of the given {@code type}. "Subtype" is defined according to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type arguments</a> introduced with Java generics. @since 19.0
